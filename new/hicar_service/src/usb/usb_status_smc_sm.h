//
// ex: set ro:
// DO NOT EDIT.
// generated by smc (http://smc.sourceforge.net/)
// from file : usb_status_smc.sm
//

#ifndef USB_STATUS_SMC_SM_H
#define USB_STATUS_SMC_SM_H


#define SMC_USES_IOSTREAMS

#include <statemap.h>
#include "hicar_usb_def.h"

namespace hsae
{
    // Forward declarations.
    class USBStatusMap;
    class USBStatusMap_WaitUsbPlugin;
    class USBStatusMap_WaitUsbNcmSwitch;
    class USBStatusMap_WaitIfaceIpAddrSetting;
    class USBStatusMap_WaitMdnsStatus;
    class USBStatusMap_DiscoverFinish;
    class USBStatusMap_ProcessError;
    class USBStatusMap_Default;
    class hicar_usb_managerState;
    class usb_status_smcContext;
    class hicar_usb_manager;

    class hicar_usb_managerState :
        public statemap::State
    {
    public:

        hicar_usb_managerState(const char * const name, const int stateId)
        : statemap::State(name, stateId)
        {};

        virtual void Entry(usb_status_smcContext&) {};
        virtual void Exit(usb_status_smcContext&) {};

        virtual void active_ncm_switch_successful(usb_status_smcContext& context);
        virtual void active_num_swich_failure(usb_status_smcContext& context);
        virtual void iface_ip_is_ok(usb_status_smcContext& context);
        virtual void mdns_activation_failed(usb_status_smcContext& context);
        virtual void mdns_already_activated(usb_status_smcContext& context);
        virtual void ncm_dev_up(usb_status_smcContext& context);
        virtual void timeout(usb_status_smcContext& context, usb_sm_status _status);
        virtual void unplug(usb_status_smcContext& context);

    protected:

        virtual void Default(usb_status_smcContext& context);
    };

    class USBStatusMap
    {
    public:

        static USBStatusMap_WaitUsbPlugin WaitUsbPlugin;
        static USBStatusMap_WaitUsbNcmSwitch WaitUsbNcmSwitch;
        static USBStatusMap_WaitIfaceIpAddrSetting WaitIfaceIpAddrSetting;
        static USBStatusMap_WaitMdnsStatus WaitMdnsStatus;
        static USBStatusMap_DiscoverFinish DiscoverFinish;
        static USBStatusMap_ProcessError ProcessError;
    };

    class USBStatusMap_Default :
        public hicar_usb_managerState
    {
    public:

        USBStatusMap_Default(const char * const name, const int stateId)
        : hicar_usb_managerState(name, stateId)
        {};

        virtual void unplug(usb_status_smcContext& context);
        virtual void mdns_activation_failed(usb_status_smcContext& context);
        virtual void Default(usb_status_smcContext& context);
        virtual void timeout(usb_status_smcContext& context, usb_sm_status _status);
    };

    class USBStatusMap_WaitUsbPlugin :
        public USBStatusMap_Default
    {
    public:
        USBStatusMap_WaitUsbPlugin(const char * const name, const int stateId)
        : USBStatusMap_Default(name, stateId)
        {};

        virtual void Entry(usb_status_smcContext&);
        virtual void Exit(usb_status_smcContext&);
        virtual void active_ncm_switch_successful(usb_status_smcContext& context);
        virtual void active_num_swich_failure(usb_status_smcContext& context);
    };

    class USBStatusMap_WaitUsbNcmSwitch :
        public USBStatusMap_Default
    {
    public:
        USBStatusMap_WaitUsbNcmSwitch(const char * const name, const int stateId)
        : USBStatusMap_Default(name, stateId)
        {};

        virtual void Entry(usb_status_smcContext&);
        virtual void Exit(usb_status_smcContext&);
        virtual void ncm_dev_up(usb_status_smcContext& context);
        virtual void unplug(usb_status_smcContext& context);
    };

    class USBStatusMap_WaitIfaceIpAddrSetting :
        public USBStatusMap_Default
    {
    public:
        USBStatusMap_WaitIfaceIpAddrSetting(const char * const name, const int stateId)
        : USBStatusMap_Default(name, stateId)
        {};

        virtual void Entry(usb_status_smcContext&);
        virtual void Exit(usb_status_smcContext&);
        virtual void iface_ip_is_ok(usb_status_smcContext& context);
    };

    class USBStatusMap_WaitMdnsStatus :
        public USBStatusMap_Default
    {
    public:
        USBStatusMap_WaitMdnsStatus(const char * const name, const int stateId)
        : USBStatusMap_Default(name, stateId)
        {};

        virtual void Entry(usb_status_smcContext&);
        virtual void Exit(usb_status_smcContext&);
        virtual void mdns_activation_failed(usb_status_smcContext& context);
        virtual void mdns_already_activated(usb_status_smcContext& context);
    };

    class USBStatusMap_DiscoverFinish :
        public USBStatusMap_Default
    {
    public:
        USBStatusMap_DiscoverFinish(const char * const name, const int stateId)
        : USBStatusMap_Default(name, stateId)
        {};

        virtual void Entry(usb_status_smcContext&);
        virtual void Exit(usb_status_smcContext&);
        virtual void unplug(usb_status_smcContext& context);
    };

    class USBStatusMap_ProcessError :
        public USBStatusMap_Default
    {
    public:
        USBStatusMap_ProcessError(const char * const name, const int stateId)
        : USBStatusMap_Default(name, stateId)
        {};

        virtual void Entry(usb_status_smcContext&);
        virtual void Exit(usb_status_smcContext&);
    };

    class usb_status_smcContext :
        public statemap::FSMContext
    {
    public:

        explicit usb_status_smcContext(hicar_usb_manager& owner)
        : FSMContext(USBStatusMap::WaitUsbPlugin),
          _owner(owner)
        {};

        usb_status_smcContext(hicar_usb_manager& owner, const statemap::State& state)
        : FSMContext(state),
          _owner(owner)
        {};

        virtual void enterStartState()
        {
            getState().Entry(*this);
            return;
        }

        inline hicar_usb_manager& getOwner()
        {
            return (_owner);
        };

        inline hicar_usb_managerState& getState()
        {
            if (_state == NULL)
            {
                throw statemap::StateUndefinedException();
            }

            return dynamic_cast<hicar_usb_managerState&>(*_state);
        };

        inline void active_ncm_switch_successful()
        {
            getState().active_ncm_switch_successful(*this);
        };

        inline void active_num_swich_failure()
        {
            getState().active_num_swich_failure(*this);
        };

        inline void iface_ip_is_ok()
        {
            getState().iface_ip_is_ok(*this);
        };

        inline void mdns_activation_failed()
        {
            getState().mdns_activation_failed(*this);
        };

        inline void mdns_already_activated()
        {
            getState().mdns_already_activated(*this);
        };

        inline void ncm_dev_up()
        {
            getState().ncm_dev_up(*this);
        };

        inline void timeout(usb_sm_status _status)
        {
            getState().timeout(*this, _status);
        };

        inline void unplug()
        {
            getState().unplug(*this);
        };

    private:
        hicar_usb_manager& _owner;
    };
}


#endif // USB_STATUS_SMC_SM_H

//
// Local variables:
//  buffer-read-only: t
// End:
//

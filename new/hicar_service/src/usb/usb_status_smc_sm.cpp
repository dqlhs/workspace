//
// ex: set ro:
// DO NOT EDIT.
// generated by smc (http://smc.sourceforge.net/)
// from file : usb_status_smc.sm
//


// hicar usb status
//



#include "hicar_usb_manager.h"
#include "usb_status_smc_sm.h"

using namespace statemap;

namespace hsae
{
    // Static class declarations.
    USBStatusMap_WaitUsbPlugin USBStatusMap::WaitUsbPlugin("USBStatusMap::WaitUsbPlugin", 0);
    USBStatusMap_WaitUsbNcmSwitch USBStatusMap::WaitUsbNcmSwitch("USBStatusMap::WaitUsbNcmSwitch", 1);
    USBStatusMap_WaitIfaceIpAddrSetting USBStatusMap::WaitIfaceIpAddrSetting("USBStatusMap::WaitIfaceIpAddrSetting", 2);
    USBStatusMap_WaitMdnsStatus USBStatusMap::WaitMdnsStatus("USBStatusMap::WaitMdnsStatus", 3);
    USBStatusMap_DiscoverFinish USBStatusMap::DiscoverFinish("USBStatusMap::DiscoverFinish", 4);
    USBStatusMap_ProcessError USBStatusMap::ProcessError("USBStatusMap::ProcessError", 5);

    void hicar_usb_managerState::active_ncm_switch_successful(usb_status_smcContext& context)
    {
        Default(context);
    }

    void hicar_usb_managerState::active_num_swich_failure(usb_status_smcContext& context)
    {
        Default(context);
    }

    void hicar_usb_managerState::iface_ip_is_ok(usb_status_smcContext& context)
    {
        Default(context);
    }

    void hicar_usb_managerState::mdns_activation_failed(usb_status_smcContext& context)
    {
        Default(context);
    }

    void hicar_usb_managerState::mdns_already_activated(usb_status_smcContext& context)
    {
        Default(context);
    }

    void hicar_usb_managerState::ncm_dev_up(usb_status_smcContext& context)
    {
        Default(context);
    }

    void hicar_usb_managerState::timeout(usb_status_smcContext& context, usb_sm_status _status)
    {
        Default(context);
    }

    void hicar_usb_managerState::unplug(usb_status_smcContext& context)
    {
        Default(context);
    }

    void hicar_usb_managerState::Default(usb_status_smcContext& context)
    {
        throw (
            TransitionUndefinedException(
                context.getState().getName(),
                context.getTransition()));

    }

    void USBStatusMap_Default::unplug(usb_status_smcContext& context)
    {
        hicar_usb_manager& ctxt = context.getOwner();

        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.clear_status_check();
            context.setState(USBStatusMap::WaitUsbPlugin);
        }
        catch (...)
        {
            context.setState(USBStatusMap::WaitUsbPlugin);
            throw;
        }
        context.getState().Entry(context);

    }

    void USBStatusMap_Default::mdns_activation_failed(usb_status_smcContext& context)
    {


    }

    void USBStatusMap_Default::Default(usb_status_smcContext& context)
    {


    }

    void USBStatusMap_Default::timeout(usb_status_smcContext& context, usb_sm_status _status)
    {
        hicar_usb_manager& ctxt = context.getOwner();

        if (ctxt.current_status() == _status)
        {
            context.getState().Exit(context);
            // No actions.
            context.setState(USBStatusMap::ProcessError);
            context.getState().Entry(context);
        }
        else
        {
        }

    }

    void USBStatusMap_WaitUsbPlugin::Entry(usb_status_smcContext& context)

{
        hicar_usb_manager& ctxt = context.getOwner();

        ctxt.set_current_status(usb_sm_status::wait_huawei_usb_plugin);
    }

    void USBStatusMap_WaitUsbPlugin::Exit(usb_status_smcContext& context)

{
        hicar_usb_manager& ctxt = context.getOwner();

        ctxt.set_previous_status(ctxt.current_status());
    }

    void USBStatusMap_WaitUsbPlugin::active_ncm_switch_successful(usb_status_smcContext& context)
    {
        hicar_usb_manager& ctxt = context.getOwner();

        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.add_status_check("ncm_dev_check", std::bind(&hicar_usb_manager::ncm_dev_check, std::ref(ctxt)));
            context.setState(USBStatusMap::WaitUsbNcmSwitch);
        }
        catch (...)
        {
            context.setState(USBStatusMap::WaitUsbNcmSwitch);
            throw;
        }
        context.getState().Entry(context);

    }

    void USBStatusMap_WaitUsbPlugin::active_num_swich_failure(usb_status_smcContext& context)
    {

        context.getState().Exit(context);
        context.setState(USBStatusMap::ProcessError);
        context.getState().Entry(context);

    }

    void USBStatusMap_WaitUsbNcmSwitch::Entry(usb_status_smcContext& context)

{
        hicar_usb_manager& ctxt = context.getOwner();

        ctxt.set_current_status(usb_sm_status::wait_usb_ncm_switch);
    }

    void USBStatusMap_WaitUsbNcmSwitch::Exit(usb_status_smcContext& context)

{
        hicar_usb_manager& ctxt = context.getOwner();

        ctxt.set_previous_status(ctxt.current_status());
    }

    void USBStatusMap_WaitUsbNcmSwitch::ncm_dev_up(usb_status_smcContext& context)
    {
        hicar_usb_manager& ctxt = context.getOwner();

        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.set_iface_ip();
            ctxt.post_event(std::bind(&hicar_usb_manager::iface_ip_check, std::ref(ctxt)));
            ctxt.add_status_check("iface_ip_check", std::bind(&hicar_usb_manager::iface_ip_check, std::ref(ctxt)));
            ctxt.notify_usb_plug_status(usb_plug_status::plugin);
            context.setState(USBStatusMap::WaitIfaceIpAddrSetting);
        }
        catch (...)
        {
            context.setState(USBStatusMap::WaitIfaceIpAddrSetting);
            throw;
        }
        context.getState().Entry(context);

    }

    void USBStatusMap_WaitUsbNcmSwitch::unplug(usb_status_smcContext& context)
    {


    }

    void USBStatusMap_WaitIfaceIpAddrSetting::Entry(usb_status_smcContext& context)

{
        hicar_usb_manager& ctxt = context.getOwner();

        ctxt.set_current_status(usb_sm_status::wait_ip_addr_setting);
    }

    void USBStatusMap_WaitIfaceIpAddrSetting::Exit(usb_status_smcContext& context)

{
        hicar_usb_manager& ctxt = context.getOwner();

        ctxt.set_previous_status(ctxt.current_status());
    }

    void USBStatusMap_WaitIfaceIpAddrSetting::iface_ip_is_ok(usb_status_smcContext& context)
    {
        hicar_usb_manager& ctxt = context.getOwner();

        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.start_mdns_service();
            context.setState(USBStatusMap::WaitMdnsStatus);
        }
        catch (...)
        {
            context.setState(USBStatusMap::WaitMdnsStatus);
            throw;
        }
        context.getState().Entry(context);

    }

    void USBStatusMap_WaitMdnsStatus::Entry(usb_status_smcContext& context)

{
        hicar_usb_manager& ctxt = context.getOwner();

        ctxt.set_current_status(usb_sm_status::wait_mdns_start);
    }

    void USBStatusMap_WaitMdnsStatus::Exit(usb_status_smcContext& context)

{
        hicar_usb_manager& ctxt = context.getOwner();

        ctxt.set_previous_status(ctxt.current_status());
    }

    void USBStatusMap_WaitMdnsStatus::mdns_activation_failed(usb_status_smcContext& context)
    {
        hicar_usb_manager& ctxt = context.getOwner();

        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.notify_usb_plug_status(usb_plug_status::unplug);
            context.setState(USBStatusMap::ProcessError);
        }
        catch (...)
        {
            context.setState(USBStatusMap::ProcessError);
            throw;
        }
        context.getState().Entry(context);

    }

    void USBStatusMap_WaitMdnsStatus::mdns_already_activated(usb_status_smcContext& context)
    {

        context.getState().Exit(context);
        context.setState(USBStatusMap::DiscoverFinish);
        context.getState().Entry(context);

    }

    void USBStatusMap_DiscoverFinish::Entry(usb_status_smcContext& context)

{
        hicar_usb_manager& ctxt = context.getOwner();

        ctxt.set_current_status(usb_sm_status::usb_discover_finish);
    }

    void USBStatusMap_DiscoverFinish::Exit(usb_status_smcContext& context)

{
        hicar_usb_manager& ctxt = context.getOwner();

        ctxt.set_previous_status(ctxt.current_status());
    }

    void USBStatusMap_DiscoverFinish::unplug(usb_status_smcContext& context)
    {
        hicar_usb_manager& ctxt = context.getOwner();

        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.clear_status_check();
            ctxt.notify_usb_plug_status(usb_plug_status::unplug);
            context.setState(USBStatusMap::WaitUsbPlugin);
        }
        catch (...)
        {
            context.setState(USBStatusMap::WaitUsbPlugin);
            throw;
        }
        context.getState().Entry(context);

    }

    void USBStatusMap_ProcessError::Entry(usb_status_smcContext& context)

{
        hicar_usb_manager& ctxt = context.getOwner();

        ctxt.set_current_status(usb_sm_status::process_error);
    }

    void USBStatusMap_ProcessError::Exit(usb_status_smcContext& context)

{
        hicar_usb_manager& ctxt = context.getOwner();

        ctxt.set_previous_status(ctxt.current_status());
    }
}

//
// Local variables:
//  buffer-read-only: t
// End:
//
